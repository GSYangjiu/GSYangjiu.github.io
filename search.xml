<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LeetCode一百题</title>
      <link href="/posts/4962c1ea.html"/>
      <url>/posts/4962c1ea.html</url>
      
        <content type="html"><![CDATA[<h1 id="一百题"><a href="#一百题" class="headerlink" title="一百题"></a>一百题</h1><p>二月开始刷leetcode，一百题了，再接再厉。</p><p>还有就是什么时候才能看得到排名。</p><p><img src="http://img.yukio.top/blog/post/20220307/16-20-48-5cd1b5.jpg" alt="nginx -t"></p>]]></content>
      
      
      <categories>
          
          <category> 琐事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杭州 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker部署Nginx镜像</title>
      <link href="/posts/f3b67776.html"/>
      <url>/posts/f3b67776.html</url>
      
        <content type="html"><![CDATA[<h1 id="nginx镜像拉取"><a href="#nginx镜像拉取" class="headerlink" title="nginx镜像拉取"></a>nginx镜像拉取</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx</span><br></pre></td></tr></table></figure><h1 id="创建挂载目录"><a href="#创建挂载目录" class="headerlink" title="创建挂载目录"></a>创建挂载目录</h1><p>根目录 <em>&#x2F;home&#x2F;docker&#x2F;nginx&#x2F;</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ./conf</span><br><span class="line"><span class="built_in">mkdir</span> ./html</span><br><span class="line"><span class="built_in">mkdir</span> ./logs</span><br></pre></td></tr></table></figure><h1 id="启动测试容器"><a href="#启动测试容器" class="headerlink" title="启动测试容器"></a>启动测试容器</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##启动测试容器</span></span><br><span class="line">docker run --name <span class="built_in">test</span> -d nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">##复制配置文件</span></span><br><span class="line">docker <span class="built_in">cp</span> <span class="built_in">test</span>:/etc/nginx/nginx.conf /home/docker/nginx/conf/</span><br><span class="line">docker <span class="built_in">cp</span> <span class="built_in">test</span>:/etc/nginx/conf.d/default.conf  /home/docker/nginx/conf.d</span><br></pre></td></tr></table></figure><p>nginx镜像中的配置文件路径默认是<em>etc&#x2F;nginx&#x2F;nginx.conf</em>, 也可以进入镜像<em>nginx -t</em>确认下。</p><p><img src="http://img.yukio.top/blog/post/20220217/18-53-39-iShot2022-02-14-f2f1dc.png" alt="nginx -t"></p><p>访问下服务器ip，nginx启动默认监听80端口，确认没问题就<em>docker rm</em>掉刚刚的test容器，开始正式部署。</p><h1 id="正式部署"><a href="#正式部署" class="headerlink" title="正式部署"></a>正式部署</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx --privileged -it -p 80:80 \</span><br><span class="line">-v /home/docker/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro \</span><br><span class="line">-v /home/docker/nginx/conf/conf.d:/etc/nginx/conf.d:ro \</span><br><span class="line">-v /home/docker/nginx/html:/usr/share/nginx/html:rw  \</span><br><span class="line">-v /home/docker/nginx/logs:/var/log/nginx \</span><br><span class="line">-d nginx</span><br></pre></td></tr></table></figure><p>启动后<em>docker ps -a</em>查看下容器状态。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="ngxin访问403"><a href="#ngxin访问403" class="headerlink" title="ngxin访问403"></a>ngxin访问403</h2><p>有几种可能：</p><p>1.网站资源文件挂载失败，ngxin配置文件写错</p><p><em>docker exec -it 容器id &#x2F;bin&#x2F;bash</em>进入容器内部确认下挂载路径下有没有对应html文件。</p><p>查看下nginx配置文件（nginx.conf和default.conf）确认下路径是否拼写错误</p><p>2.nginx启动用户和工作用户不一致</p><p>docker启动ngxin用的是root用户，而nginx默认配置文件中用的是nginx用户。</p><p>将配置文件中的<del>user nginx</del> 修改成<em>user root</em>就OK了</p><p><img src="http://img.yukio.top/blog/post/20220217/18-53-45-iShot2022-02-14.21.07.43-ed8127.jpg" alt="ngixn-config"></p><p>3.其他</p><p>其他问题使用命令<em>docker logs 容器id</em>，看下日志具体是什么错误，具体解决。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杭州 </tag>
            
            <tag> Docker </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛型extends和super</title>
      <link href="/posts/7a59090.html"/>
      <url>/posts/7a59090.html</url>
      
        <content type="html"><![CDATA[<h1 id="前景"><a href="#前景" class="headerlink" title="前景"></a>前景</h1><p>不带继承的泛型使用很简单，基本上熟悉了Java多态就能很轻松的使用，但是日常中阅读源码时经常会碰到具有继承关系的泛型使用，<strong>extends</strong> 和 <strong>super</strong> ，例如Collections中的copy方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">copy</span><span class="params">(List&lt;? <span class="built_in">super</span> T&gt; dest, List&lt;? extends T&gt; src)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">srcSize</span> <span class="operator">=</span> src.size();</span><br><span class="line">    <span class="keyword">if</span> (srcSize &gt; dest.size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Source does not fit in dest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (srcSize &lt; COPY_THRESHOLD ||</span><br><span class="line">        (src <span class="keyword">instanceof</span> RandomAccess &amp;&amp; dest <span class="keyword">instanceof</span> RandomAccess)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++)</span><br><span class="line">            dest.set(i, src.get(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListIterator&lt;? <span class="built_in">super</span> T&gt; di=dest.listIterator();</span><br><span class="line">        ListIterator&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; si=src.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;srcSize; i++) &#123;</span><br><span class="line">            di.next();</span><br><span class="line">            di.set(si.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候就有点糊，往往一带而过，知道这个函数大概是接收个什么参数然后就继续往下看实现了，但长期以往总是一知半解，基础就很薄弱了，说起什么好像都懂一点但做起来就磕磕碰碰。搞技术一定要稳扎稳打，不能畏难，不能抱有侥幸。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>首先，**&lt;? extends T&gt;** 和 <strong>&lt;? super T&gt;</strong> 是Java泛型中的“通配符（Wildcards）”和“边界（Bounds）”的概念。</p><blockquote><? extends T>：是指 “上界通配符（Upper Bounds Wildcards）”   <? super T>：是指 “下界通配符（Lower Bounds Wildcards）”</blockquote><p><strong>里氏替换原则</strong></p><blockquote><p>子类完全拥有父类的方法，且具体子类必须实现父类的抽象方法。<br>子类中可以增加自己的方法。<br>当子类覆盖或实现父类的方法时，方法的形参要比父类方法的更为宽松。<br>当子类覆盖或实现父类的方法时，方法的返回值要比父类更严格。     </p></blockquote><p><strong>协变和逆变</strong><br>逆变与协变用来描述类型转换（type transformation）后的继承关系，其定义：如果A、B表示类型，f(⋅)表示类型转换，≤表示继承关系（比如，A≤B表示A是由B派生出来的子类；</p><blockquote><p>f(⋅)是逆变（contravariant）的，当A≤B时有f(B)≤f(A)成立；<br>f(⋅)是协变（covariant）的，当A≤B时有f(A)≤f(B)成立；<br>f(⋅)是不变（invariant）的，当A≤B时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系；</p></blockquote><h1 id="为什么要使用通配符"><a href="#为什么要使用通配符" class="headerlink" title="为什么要使用通配符"></a>为什么要使用通配符</h1><p>举个例子，我们现在用Fruit类和他的派生类Apple，和一个最简单的容器类：Plate。Plate可以放一个“泛型”的东西。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Food</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fruit</span> <span class="keyword">extends</span> <span class="title class_">Food</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> <span class="keyword">extends</span> <span class="title class_">Fruit</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Plate</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> T item;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Plate</span><span class="params">(T t)</span>&#123;item=t;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T t)</span>&#123;item=t;&#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span>&#123;<span class="keyword">return</span> item;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我定义一个“水果盘子”，逻辑上水果盘子当然可以装苹果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;Fruit&gt; plate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br></pre></td></tr></table></figure><p>但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。编辑器的逻辑是：</p><blockquote><p>苹果 IS-A 水果<br>装苹果的盘子 NOT-IS-A 装水果的盘子</p></blockquote><p>容器里装的东西之间具有继承关系，但是容器之间是没有继承关系的。为了解决这个问题，&lt;? extends T&gt; 和 &lt;? super T&gt;就被发明了。<br>而Java中的泛型是不变的，extends和super从根本上讲是为了把数据类型的关系延续到容器上，实现协变和逆变。</p><h1 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h1><p><strong>&lt;? extends T&gt;</strong> 实现了泛型的协变，例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; plate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;();</span><br><span class="line"><span class="comment">//泛型擦除后，变为：</span></span><br><span class="line">Plate&lt;Apple&gt; plate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;();</span><br></pre></td></tr></table></figure><p><strong>&lt;? super T&gt;</strong> 实现了泛型的逆变，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? <span class="built_in">super</span> Fruit&gt; plate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Food&gt;();</span><br><span class="line"><span class="comment">//泛型擦除后，变为：</span></span><br><span class="line">Plate&lt;Food&gt; plate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Food&gt;();</span><br></pre></td></tr></table></figure><p>通过 <strong>&lt;? extends T&gt;</strong> 和 <strong>&lt;? super T&gt;</strong> 实现了泛型的协变和逆变，而且没有破坏里氏替换原则。</p><h1 id="上下界通配符的副作用"><a href="#上下界通配符的副作用" class="headerlink" title="上下界通配符的副作用"></a>上下界通配符的副作用</h1><p>先看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; plate = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;&gt;();</span><br><span class="line">plate.set(<span class="keyword">new</span> <span class="title class_">Apple</span>()); <span class="comment">//Error</span></span><br></pre></td></tr></table></figure><h2 id="上界-lt-extends-T-gt-不能往里存，只能往外取"><a href="#上界-lt-extends-T-gt-不能往里存，只能往外取" class="headerlink" title="上界&lt;? extends T&gt;不能往里存，只能往外取"></a>上界&lt;? extends T&gt;不能往里存，只能往外取</h2><p>IntellIj会检测到编译时异常，通常我们会觉得，plate是个装水果的盘子，为什么不能装苹果？因为编译器没办法确定Plate存放的具体的元素类型，只能知道是个Fruit的子类，你放了一个Apple，Apple是Fruit的子类，但是编译器不能确定Plate中要放的是不是Apple。**&lt;? extends T&gt;** 只能确保Plate中的元素一定是Fruit的子类，并不是指只要是Fruit的子类就一定能放到Plate中，所以叫做 <strong>上界通配符</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; p = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Apple&gt;(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能存入任何元素</span></span><br><span class="line">p.set(<span class="keyword">new</span> <span class="title class_">Fruit</span>());    <span class="comment">//Error</span></span><br><span class="line">p.set(<span class="keyword">new</span> <span class="title class_">Apple</span>());    <span class="comment">//Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取出来的东西只能存放在Fruit或它的基类里。</span></span><br><span class="line"><span class="type">Fruit</span> <span class="variable">newFruit1</span> <span class="operator">=</span> p.get();</span><br><span class="line"><span class="type">Object</span> <span class="variable">newFruit2</span> <span class="operator">=</span> p.get();</span><br><span class="line"><span class="type">Apple</span> <span class="variable">newFruit3</span> <span class="operator">=</span> p.get();    <span class="comment">//Error</span></span><br></pre></td></tr></table></figure><p>同理，取的时候不能用Apple去接，只能用Fruit或者Fruit的基类去接。</p><h2 id="下界-lt-super-T-gt-不影响往里存，但往外取只能放在Object对象里"><a href="#下界-lt-super-T-gt-不影响往里存，但往外取只能放在Object对象里" class="headerlink" title="下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里"></a>下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? <span class="built_in">super</span> Fruit&gt; p = <span class="keyword">new</span> <span class="title class_">Plate</span>&lt;Fruit&gt;(<span class="keyword">new</span> <span class="title class_">Fruit</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//存入元素正常</span></span><br><span class="line">p.set(<span class="keyword">new</span> <span class="title class_">Fruit</span>());</span><br><span class="line">p.set(<span class="keyword">new</span> <span class="title class_">Apple</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取出来的东西只能存放在Object类里。</span></span><br><span class="line"><span class="type">Apple</span> <span class="variable">newFruit3</span> <span class="operator">=</span> p.get();    <span class="comment">//Error</span></span><br><span class="line"><span class="type">Fruit</span> <span class="variable">newFruit1</span> <span class="operator">=</span> p.get();    <span class="comment">//Error</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">newFruit2</span> <span class="operator">=</span> p.get();</span><br></pre></td></tr></table></figure><p>当时用 <strong>&lt;? super T&gt;</strong> 时，编译器会知道Plate中的元素一定是Fruit或Fruit的基类，而Apple是Fruit的子类，所以可以向Plate中添加Apple，但取的时候不能确定取出来究竟是Fruit的哪个父类，只能用所有对象的父类Object来接收，元素的类型信息就会丢失。</p><h1 id="PECS-Producer-Extends-Consumer-Super"><a href="#PECS-Producer-Extends-Consumer-Super" class="headerlink" title="PECS (Producer Extends Consumer Super)"></a>PECS (Producer Extends Consumer Super)</h1><p>究竟什么时候用extends什么时候用super呢？《Effective Java》给出了答案：</p><p>例如，一个简单的Stack API：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title class_">Stack</span>&lt;E&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E e)</span>:</span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现pushAll(Iterable<E> src)方法，将src的元素逐一入栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushAll</span><span class="params">(Iterable&lt;E&gt; src)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(E e : src)</span><br><span class="line">        push(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有一个实例化Stack<Number>的对象stack，src有Iterable<Integer>与 Iterable<Float>；在调用pushAll方法时会发生type mismatch错误，因为Java中泛型是不可变的，Iterable<Integer>与 Iterable<Float>都不是Iterable<Number>的子类型。因此，应改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushAll</span><span class="params">(Iterable&lt;? extends E&gt; src)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (E e : src)</span><br><span class="line">        push(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现popAll(Collection<E> dst)方法，将Stack中的元素依次取出add到dst中，如果不用通配符实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (!isEmpty())</span><br><span class="line">        dst.add(pop());   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，假设有一个实例化Stack<Number>的对象stack，dst为Collection<Object>；调用popAll方法是会发生type mismatch错误，因为Collection<Object>不是Collection<Number>的子类型。因而，应改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">popAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> E&gt; dst)</span> &#123;</span><br><span class="line"><span class="keyword">while</span> (!isEmpty())</span><br><span class="line">    dst.add(pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述例子中，在调用pushAll方法时生产了E 实例（produces E instances），在调用popAll方法时dst消费了E 实例（consumes E instances）。Naftalin与Wadler将PECS称为Get and Put Principle。</p><p>再回到文章开头java.util.Collections的copy方法，<strong>List&lt;? extends T&gt; src</strong> 生产了T实例 <strong>List&lt;? super T&gt; dest</strong> 消费了T实例，总结一下就是：</p><blockquote><p>要从泛型类取数据时，用extends；<br>要往泛型类写数据时，用super；<br>既要取又要写，就不用通配符（即extends与super都不用）。</p></blockquote><h1 id="参考博文"><a href="#参考博文" class="headerlink" title="参考博文"></a>参考博文</h1><ol><li>Treant <a href="http://www.cnblogs.com/en-heng/">Java中的逆变与协变</a>    </li><li>Mr.Seven <a href="https://itimetraveler.github.io/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E4%B8%AD%20extends%20%E5%92%8C%20super%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/">Java泛型中 extends 和 super 的区别？</a>   </li><li>yi_afly <a href="https://blog.csdn.net/yi_afly/article/details/52002594">Java泛型的实现：原理与问题</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> document </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 武汉 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/posts/e8eb0481.html"/>
      <url>/posts/e8eb0481.html</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>二分查找</strong> 也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字 <strong>有序排列</strong>。</p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><blockquote><p>假设R[low…high]是当前的查找区间，key为需要查找的值。<br>1.先确定该区间的中间位置：<strong>mid &#x3D; （low+high）&#x2F;2</strong>。<br>2.将key值域R[mid]比较：若相等，则查找成功并返回此位置，否则进一步确定新的查找区间:<br>    若R[mid]&gt;key，则可知，如果表中存在关键字等于key的结点，则该结点位置一定位于mid的左边的子表R[1…mid-1]中。<br>    若R[mid]&lt;key，则可知，如果表中存在关键字等于key的结点，则该结点位置一定位于mid的右边的子表R[mid+1…high]中。<br>3.每经过一次查找，查找区间就会减半，重复这一过程直到找到关键字为key的结点，或缩减至查找子区间右侧小于左侧，则区间不存在，查找失败，按照一般约定，没有找到目标元素，则把应该插入目标元素的位置返回。</p></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="循环实现"><a href="#循环实现" class="headerlink" title="循环实现"></a>循环实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="comment">//不要用（low+high）/2,可能溢出。规范：low + (high - low) / 2;</span></span><br><span class="line">            mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &lt; key) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有找到目标元素，则把应该插入的位置返回</span></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">binarySearchRecur</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> key, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> low;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearchRecur(arr, key, mid + <span class="number">1</span>, high);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearchRecur(arr, key, low, mid - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是获取mid值得时候不要直接使用：<strong>mid &#x3D; （low+high）&#x2F;2</strong>，因为当 <strong>low+high&gt;Integer.Max</strong> 的时候会溢出，所以要用 <strong>mid &#x3D; low + (high - low) &#x2F; 2</strong> 来获取mid的值。</p><h2 id="包含重复元素数组"><a href="#包含重复元素数组" class="headerlink" title="包含重复元素数组"></a>包含重复元素数组</h2><p>上面两个方法只能处理不包含重复数据的数组，否则返回结果会不准确<br>例：当时组为 int a[] &#x3D; {1, 2, 3, 4, 5, 7, 7, 9, 10} 时<br>第一次查找区间缩减为{7, 7, 9, 10}, low&#x3D;5，high&#x3D;8，此时mid&#x3D;6，a[6]&#x3D;7, 查找成功返回结点位置6，但数组a中第一次出现7的位置应该是a[5],而不是a[6];</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">firstOccurrence</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> mid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; key) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt;= key) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">firstOccurrenceRecur</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> key, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> low;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; key) &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearchRecur(arr, key, mid + <span class="number">1</span>, high);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> binarySearchRecur(arr, key, low, mid - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过与上面代码比较发现仅仅是修改判定条件 <strong>arr[mid] &gt; key</strong> 为 <strong>arr[mid] &gt;&#x3D; key</strong>，这样当arr[mid] &#x3D; key时，会继续执行循环体，而不是直接返回查找到的位置，在这次循环中，主要是判断arr[mid-1]是否等于key，如果相等则第一次出现关键字为key的结点的位置就会前移一位。high不断向low逼近，直到high&lt;low，此时循环结束，返回第一次出现关键字为key的结点位置。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>二分查找的时间复杂度为O(logn)，远远好于顺序查找的O(n)。但是使用二分查找前，必须将表按关键字排序，而排序本身是一种比较费时的运算，即使采用高效的排序方法也要花费O(nlogn)的时间。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>根据二分查找的优缺点我们可以想到，二分查找特别适用于那种一经建立就很少改动，而又经常需要查找的线性表。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 武汉 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域与解决方案</title>
      <link href="/posts/e2be36a1.html"/>
      <url>/posts/e2be36a1.html</url>
      
        <content type="html"><![CDATA[<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p><strong>前后端分离项目</strong> 经常需要处理跨域问题，总所周知，跨域问题是由于浏览器的 <em>同源策略</em> 导致的。所以先介绍下浏览器同源策略： <strong>“如果两个页面的协议，域名和端口（如果有指定）都相同，则两个页面具有相同的源。”</strong></p><p>例如相对于<a href="http://www.yangmiemie.info/index/page.html">http://www.yangmiemie.info/index/page.html</a>网址：</p><table><thead><tr><th>URL</th><th>同源</th><th>原因</th></tr></thead><tbody><tr><td><code>http://www.yangmiemie.info/index/other.html</code></td><td>成功</td><td></td></tr><tr><td><code>http://www.yangmiemie.info/index/inner/another.html</code></td><td>成功</td><td></td></tr><tr><td><code>https://www.yangmiemie.info/secure.html</code></td><td>失败</td><td>不同协议 ( https和http )</td></tr><tr><td><code>http://www.yangmiemie.info:81/index/etc.html</code></td><td>失败</td><td>不同端口 ( 81和80)</td></tr><tr><td><code>http://github.yangmiemie.info/index/other.html</code></td><td>失败</td><td>不同域名 ( www和github )</td></tr></tbody></table><p>不同源的网址访问就会发生跨域问题，主要是浏览器为了防止CSRF攻击，什么是CSRF攻击就不展开讲了，简单描述一下就是现在绝大部分浏览器都是cookie共享的，如果你同时打开了网站A和钓鱼网站B，由于你已经登陆了网站A，sessionId已经储存在cookie中，网站B可以利用网站A的cookie发起直接向网站A服务器发起恶意请求，实现攻击操作。由于有同源策略，网站B发起的Ajax请求就会失败。</p><p>那么如果我们的项目是前后端分离的，前后端部署在不同的服务器上，发起的请求也都是不同源的，这个时候就需要实现跨域访问了。一般跨域解决方案有两种，<strong>jsonp</strong> 和 <strong>cors</strong>。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h2><p>jsop解决跨域问题较为简单粗暴，基本思想是，网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源政策限制( <strong>拥有”src”这个属性的标签都拥有跨域的能力</strong> )；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。jsonp需要在URL后追加一个 <strong>callback</strong> 参数指定回调函数名。<br>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">addScriptTag</span>(<span class="params">src</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    script.<span class="title function_">setAttribute</span>(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;text/javascript&quot;</span>);</span><br><span class="line">    script.<span class="property">src</span> = src;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">addScriptTag</span>(<span class="string">&#x27;http://www.yangmiemie.info/getUserName?id=001&amp;callback=show&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">show</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;username is &#x27;</span> + data.<span class="property">username</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码是jsonp的实现原理，平时如果使用jquery进行跨域请求，代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line">         <span class="attr">type</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">         <span class="attr">async</span>: <span class="literal">false</span>,</span><br><span class="line">         <span class="attr">url</span>: <span class="string">&quot;http://www.yangmiemie.info/getUserName?id=001&quot;</span>,</span><br><span class="line">         <span class="attr">dataType</span>: <span class="string">&quot;jsonp&quot;</span>,</span><br><span class="line">         <span class="attr">jsonp</span>: <span class="string">&quot;callback&quot;</span>,<span class="comment">//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)</span></span><br><span class="line">         <span class="attr">jsonpCallback</span>:<span class="string">&quot;show&quot;</span>,<span class="comment">//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写&quot;?&quot;，jQuery会自动为你处理数据</span></span><br><span class="line">         <span class="attr">success</span>: <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;username is &#x27;</span> + data.<span class="property">username</span>);</span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">error</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">             <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fail&#x27;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure><p>服务器支持jsonp，必须通过jsonp参数获取jsonp回调函数名的参数名，然后按指定格式返回，所以可以在后台添加逻辑控制，比如指定可以跨域接口，来确保服务器安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">callback</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;callback&quot;</span>); <span class="comment">//不指定函数名默认 callback</span></span><br><span class="line"><span class="keyword">return</span> callback + <span class="string">&quot;(&quot;</span> + jsonStr + <span class="string">&quot;)&quot;</span></span><br></pre></td></tr></table></figure><p>需要注意的是jsonp只能发送 <strong>get</strong> 请求。</p><h2 id="cors"><a href="#cors" class="headerlink" title="cors"></a>cors</h2><p>相对于 <strong>jsonp</strong>， <strong>cors</strong>原理较为复杂，但是使用cors非常简单，因为现在大多数浏览器的支持，整个cors的通信过程，都是浏览器自动完成的，不需要用户参与。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><h3 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h3><p>浏览器将cors请求分成两类，简单请求和非简单请求，只要同时满足以下两大条件，就属于简单请求。</p><blockquote><p>(1) 请求方法是以下三种方法之一：<br>   HEAD<br>   GET<br>   POST<br>(2) HTTP的头信息不超出以下几种字段：<br>   Accept<br>   Accept-Language<br>   Content-Language<br>   Last-Event-ID<br>   Content-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</p></blockquote><h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。<br>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。</p><blockquote><p>GET &#x2F;cors HTTP&#x2F;1.1<br>Origin: <a href="http://api.bob.com/">http://api.bob.com</a><br>Host: api.alice.com<br>Accept-Language: en-US<br>Connection: keep-alive<br>User-Agent: Mozilla&#x2F;5.0…  </p></blockquote><p>Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>当请求方法不满足简单请求的两大条件时，比如请求方法是PUT或DELETE，或者Content-Type字段类型是application&#x2F;json，该次请求就属于非简单请求。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>预检请求响应头</p><blockquote><p>OPTIONS &#x2F;cors HTTP&#x2F;1.1<br>Origin: <a href="http://api.bob.com/">http://api.bob.com</a><br>Access-Control-Request-Method: PUT<br>Access-Control-Request-Headers: X-Custom-Header<br>Host: api.alice.com<br>Accept-Language: en-US<br>Connection: keep-alive<br>User-Agent: Mozilla&#x2F;5.0…  </p></blockquote><h3 id="cors总结"><a href="#cors总结" class="headerlink" title="cors总结"></a>cors总结</h3><p>使用CORS解决跨域问题，简单来看就是在请求的请求头中添加了 <strong>Origin</strong> 字段，该字段包含请求的发起域名，服务器的响应头中包含了 <strong>Access-Control-Allow-Origin</strong> 字段，该字段包含服务器支持的域名。再加上其他可选附带字段，提供更多信息，例如 **<br>Access-Control-Allow-Methods** 、 <strong>Access-Control-Allow-Headers</strong> 、 <strong>Access-Control-Max-Age</strong> 等，这个过程客户端编码过程是无感知的，也就是说普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，可以通过服务端代码实现，也可以通过nginx配置，而前端无须设置，若要带cookie请求：服务端端需要另外开启 <strong>Access-Control-Allow-Credentials: true</strong> ，前端需要AJAX请求中打开 <strong>withCredentials</strong> 属性。</p><h2 id="jsonp和cors对比"><a href="#jsonp和cors对比" class="headerlink" title="jsonp和cors对比"></a>jsonp和cors对比</h2><p>jsonp和cors但就使用来说都较为简单，实现原理jsonp较为简单，便于理解，但是jsonp只能支持 <strong>get</strong> 请求，cors不受此限制。<br>cors更为强大和规范，jsonp更像一种早期开发者通过自身智慧想到的解决跨域问题的方案，后来用的人多了就成了一种默认的方法，而cors受到浏览器和服务端的支持，更为规范。个人建议还是使用cors来解决跨域问题。</p><h2 id="其他跨域方案"><a href="#其他跨域方案" class="headerlink" title="其他跨域方案"></a>其他跨域方案</h2><p>跨域问题其实还有很多种解决方案，包括前端到后端，总觉得一个开发者视界应该广阔些，不应局限于一种技术、语言、解决方案，才能更从容地应对千变万化的需求。</p><p>下面几种方案只简单介绍一下</p><blockquote><p>iframe</p></blockquote><p>使用iframe实现跨域，更类似于两个不同域名的网站通过iframe拼接到一起。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口：(http://www.domain.com/a.html)</span></span><br><span class="line">&lt;iframe id=<span class="string">&quot;iframe&quot;</span> src=<span class="string">&quot;http://child.domain.com/b.html&quot;</span>&gt;&lt;/iframe&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;domain.com&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="keyword">var</span> user = <span class="string">&#x27;admin&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子窗口：(http://child.domain.com/b.html)</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="variable language_">document</span>.<span class="property">domain</span> = <span class="string">&#x27;domain.com&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="comment">// 获取父窗口中变量</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"><span class="title function_">alert</span>(<span class="string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="variable language_">window</span>.<span class="property">parent</span>.<span class="property">user</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><blockquote><p>nginx代理和Nodejs中间件代理跨域</p></blockquote><p>同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。所以通过搭建一个代理服务器，转发请求以解决跨域问题。</p><blockquote><p>WebSocket协议跨域</p></blockquote><p>WebSocket已经更换了协议，都不是http\https了，它实现了浏览器与服务器全双工通信，同时允许跨域通讯，使用较少。</p>]]></content>
      
      
      <categories>
          
          <category> 技术分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 武汉 </tag>
            
            <tag> 前端 </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript ES6中export及export default的区别</title>
      <link href="/posts/e3f9c0f1.html"/>
      <url>/posts/e3f9c0f1.html</url>
      
        <content type="html"><![CDATA[<h1 id="ES6的模块化的基本规则或特点"><a href="#ES6的模块化的基本规则或特点" class="headerlink" title="ES6的模块化的基本规则或特点"></a>ES6的模块化的基本规则或特点</h1><p>1、每一个模块只加载一次， 每一个JS只执行一次， 如果下次再去加载同目录下同文件，直接从内存中读取。 一个模块就是一个单例，或者说就是一个对象；<br>2、每一个模块内声明的变量都是局部变量， 不会污染全局作用域；<br>3、模块内部的变量或者函数可以通过export导出；<br>4、一个模块可以导入别的模块_</p><h1 id="export、import和export-default"><a href="#export、import和export-default" class="headerlink" title="export、import和export default"></a>export、import和export default</h1><p>export、import这两个很好理解，从字面意思就可以知道一个导出，一个导入。</p><p>export用于对外输出本模块（一个文件可以理解为一个模块）常量、函数、文件、模块；<br>import用于在一个模块中加载另一个含有export接口的模块，通过import+(常量 | 函数 | 文件 | 模块)名的方式，将其导入。</p><p>export default也是导出区别在于export default导出相当于为模块指定默认输出，export default和import时都不需要加上大括号，通过import import的就是export default的内容，因此一个文件中export可以有多个，但是export default只能有一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js文件</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Vincent&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; name &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&quot;/.a.js&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以写成：</span></span><br><span class="line"><span class="comment">//a.js文件</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Vincent&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> name</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js文件</span></span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">&quot;/.a.js&quot;</span></span><br></pre></td></tr></table></figure><h1 id="几种导出方式"><a href="#几种导出方式" class="headerlink" title="几种导出方式"></a>几种导出方式</h1><h2 id="1、使用-export-导出"><a href="#1、使用-export-导出" class="headerlink" title="1、使用 export{} 导出"></a>1、使用 export{} 导出</h2><p>这里import要和export对应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js文件</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Vincent&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> method = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;method&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; name, method &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, method &#125; <span class="keyword">from</span> <span class="string">&quot;/.a.js&quot;</span></span><br></pre></td></tr></table></figure><h2 id="2、使用-export-a-as-b-导出"><a href="#2、使用-export-a-as-b-导出" class="headerlink" title="2、使用 export{ a as b} 导出"></a>2、使用 export{ a as b} 导出</h2><p>相当于导出时重命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js文件</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;Vincent&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; name <span class="keyword">as</span> firstName&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; firstName &#125; <span class="keyword">from</span> <span class="string">&quot;/.a.js&quot;</span></span><br></pre></td></tr></table></figure><h2 id="3、export时定义变量或者函数"><a href="#3、export时定义变量或者函数" class="headerlink" title="3、export时定义变量或者函数"></a>3、export时定义变量或者函数</h2><p>类似于Java中的匿名函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> method == <span class="function">() =&gt;</span> &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;method&quot;</span>)&#125;, name = <span class="string">&quot;vincent&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; method, name &#125; <span class="keyword">from</span> <span class="string">&quot;/.a.js&quot;</span></span><br></pre></td></tr></table></figure><h2 id="4、export-default"><a href="#4、export-default" class="headerlink" title="4、export default"></a>4、export default</h2><p>其实export default主要用于当一个js模块文件只有一个个功能的时候，直接用export default导出，导出时不需要为该模块命名,导入时自定义名称，非常方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js文件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&quot;Vincent&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js文件</span></span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">&quot;/.a.js&quot;</span></span><br></pre></td></tr></table></figure><h2 id="5、使用-export-a-as-default-导出"><a href="#5、使用-export-a-as-default-导出" class="headerlink" title="5、使用 export{ a as default} 导出"></a>5、使用 export{ a as default} 导出</h2><p>导出时将某个功能设置为默认模块，导入时自定义名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js文件</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">method</span> = (<span class="params"></span>) =&gt; <span class="string">&quot;Vincent&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; method <span class="keyword">as</span> <span class="keyword">default</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js文件</span></span><br><span class="line"><span class="keyword">import</span> &#123; defaultMethod &#125; <span class="keyword">from</span> <span class="string">&quot;/.a.js&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6、使用-export-a-from-导出"><a href="#6、使用-export-a-from-导出" class="headerlink" title="6、使用 export a from  导出"></a>6、使用 export a from  导出</h2><p>相当于导出其他模块功能，结合5使用，重命名他模块中的默认导出，再导出，多用于新建一个js，统一管理import&#x2F;export关系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">Navbar</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./Navbar&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">Sidebar</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./Sidebar/index.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">TagsView</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./TagsView&#x27;</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> <span class="title class_">AppMain</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./AppMain&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/diligenceday/p/5503777.html">https://www.cnblogs.com/diligenceday/p/5503777.html</a><br><a href="https://www.cnblogs.com/xiaotanke/p/7448383.html">https://www.cnblogs.com/xiaotanke/p/7448383.html</a></p>]]></content>
      
      
      <categories>
          
          <category> document </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 武汉 </tag>
            
            <tag> ES6 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A NEW BEGINNING</title>
      <link href="/posts/c52773ac.html"/>
      <url>/posts/c52773ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="新的开始"><a href="#新的开始" class="headerlink" title="新的开始"></a>新的开始</h1><p>2017.7.31离职，2017.8.8新公司报道，老大说他以前入职腾讯正好是8月8号。</p><p>老早就把WordPress搭建好了，但是一直没有时间折腾。有时间了就把个人博客从Github上迁移过来了。</p><p>新的博客，新的开始！</p><h1 id="深圳"><a href="#深圳" class="headerlink" title="深圳"></a>深圳</h1><p>2月份来到深圳，十几个小时的卧铺，睡了一夜就过去了。</p><p>早上八点从床上爬起来，迷迷糊糊的，被不知道什么皮的火车慢慢拖进深圳站，只是觉得深圳的阳光好亮啊，对，我说的不是太阳好亮，是阳光好亮，你懂我的意思么，就是那么亮，把什么都照的亮的一片，那时的我并不能预料到今后几个月的处境，脑子里只有一个想法，“深圳，我来了。”</p><p>关于工作上的事情不想再多说，作为一个成年人人应该为自己的选择负责。我一直相信的是mark you choose，and just do it，那时还没搞明白“其实我们每个人并不具有评判自己价值的权利”的我就跟猴群里面一直迷失了自己定位的猴子一样。我总觉得你还不知道你想要什么的时候，就慢慢走呗，总会有一天你会知道你想要什么，那时再跑也不迟。可是从学校出来后我才发现，就算你不知道你想要什么，也要拔腿就跑，因为不跑就只能被吃掉，主观上我总不愿意那些被说烂的道理，不是因为不相信它，是因为太相信自己。</p><p>还记得在罗湖的时候，经常梦见自己坐火车回武汉，但TM的怎么都赶不上那班列车，醒来都跟个SB一样。</p><h1 id="武汉"><a href="#武汉" class="headerlink" title="武汉"></a>武汉</h1><p>觉得回武汉了一切问题就能解决，找了新的工作，找了房子，由于一些原因，工作没去，房子也没租。六月底四年的酒席散场，各奔天涯，有人哭了。有人笑了。自己却没有多大感触，像只废狗一样窝在同学租的房子里，白天一个人出去晚上一个人回来，有时就想找个人问问这么操蛋的生活是为了什么，可是这个问题至今为止都还没有人回答过我。在十二楼热得不行，视频里还在讲着Spring IOC实现机制，脑子里回荡的却一直是李逼那粗糙的声音“你看荒谬的世界，你看荒谬的我们”。</p><p>后来把东西一件件打包分类，寄到深圳，就像在围墙里先把包裹扔到围墙外一样，大概就那么一个下午吧，决定了，于是就去做了，于是七月我又回到了深圳，带了本《1Q84》上的高铁，直至下车一页也没有翻过。</p><p>在武汉的时候觉得武汉这里不好哪里不好，四年时间也没有去过武汉多少地方，走的时候反倒有些留恋，还想去大桥吹江风啊，还想去一次东湖，回来的路上淋着雨在南湖大道上飞奔，还想去武理后面那条街吃烧烤上通宵，还想去百瑞景看电影，不管和谁去都行，还有好多好多想做的事情，可是这辈子都好像不会再有机会了，就像这辈子都应该不会再有机会跟你共撑一把伞了，物是人非，大抵说的就是如此。</p><p>去过阴天的大梅沙，近处的海是混浊的，远处的海是冷的，浪摇晃着把海草拍在岸上，沙滩上的我觉得这个世界都在摇晃。因为是阴天，海边的人不多，云也很低，灰色的，就像曼彻斯特的海，好吧，我承认那时还没看过《Manchester by the Sea》。我不知道是不是每个人心中都有一个Lee,放逐在充斥着阴冷的海面、颠簸的船、雪和无法消散的雾气的曼彻斯特，“I can&#96;t beat it”。</p><p>想起不知在哪里看到的一个故事，说李逼早年在livehouse开演唱会的时候，黄牛倒票卖不出去，折价都没人买，最后只好自己进去听，“这唱的什么jb玩意”。不管是什么原因，李逼再也不唱《梵高先生》了，或许在义乌小酒馆的那个夜晚，那个半醉半醒的梵高先生就已经死了吧。我想逼哥潦倒落魄的那些年，摸到吉他的时候也是很安心的吧，就像我现在摸到键盘一样。</p><h1 id="南京"><a href="#南京" class="headerlink" title="南京"></a>南京</h1><p>南京，至于南京，就留给未来吧。</p>]]></content>
      
      
      <categories>
          
          <category> 琐事 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深圳 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
