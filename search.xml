<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[webpack的使用与配置]]></title>
    <url>%2F2016%2F11%2F09%2Fwebpack%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[什么是WebpackWebPack可以看做是模块打包器：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 为什么要使用WebPack现今的很多网页其实可以看做是功能丰富的应用，它们拥有着复杂的JavaScript代码和一大堆依赖包。为了简化开发的复杂度，前端社区涌现出了很多好的实践方法模块化，让我们可以把复杂的程序细化为小的文件;优化页面加载，webpack可以将原本需要额外消耗请求的依赖打包放在一个文件里这些改进确实大大的提高了我们的开发效率，但是利用它们开发的文件往往需要进行额外的处理才能让浏览器识别,而手动处理又是非常反锁的，这就为WebPack类的工具的出现提供了需求。 准备工作1. 创建两个文件夹分别为dist和src，将源码(开发文件)放在src这个文件夹里，将生产文件放在dist文件夹里。 2.每个项目下都必须配置有一个webpack.config.js（可以取任意的名字，但是推荐用该配置名），告诉webpack它需要做什么。 3.输入npm init指令1$ npm init //生成package.json文件，存放依赖 4.在安装依赖的时候文件夹中还会多增加一个node_modules的文件夹，里面含有大量的文件，当我们在sublime中添加项目文件夹的时候为了避免因为显示node_modules文件夹而造成卡顿，可以在sublime的preferences-settings-User里面添加下面的配置。1234"folder_exclude_patterns": [ "node_modules", ] 5.添加.gitignore文件。12.DS_Storenode_modules 安装首先安装webpack1$ npm install --save webpack //项目文件夹安装 配置首先来配置webpack.config.js1234567module.exports = &#123; entry: "./src/main.js",//唯一入口文件 output: &#123; path: path.join(__dirname, "dist"),//打包后的文件存放的地方 filename: "bundle.js"//打包后输出文件的文件名 &#125;&#125; 注：“__dirname”是Node.js中的一个全局变量，它指向当前执行脚本所在的目录。 现在如果你需要打包文件只需要在终端里你运行webpack命令就可以了，这条命令会自动参考webpack.config.js文件中的配置选项打包你的项目。接下来配置packjson.json在安装那里，我们提到过npm init，一路回车就行了，再打开package.json里面可以看到下面的信息。12345678910111213&#123; "name": "",//项目名字，自动生成 "version": "1.0.0", "description": "", "scripts": &#123; //我们需要配置的地方就是这里啦 &#125;, "author": "bai", "license": "ISC", "devDependencies": &#123; "webpack": "^1.12.9"//所需要用的依赖 &#125;&#125; 使用webpack构建本地服务器想不想让你的浏览器监测你都代码的修改，并自动刷新修改后的结果，其实Webpack提供一个可选的本地开发服务器，这个本地服务器基于node.js构建，可以实现你想要的这些功能，不过它是一个单独的组件，在webpack中进行配置之前需要单独安装它作为项目依赖1$ npm install –save webapck-dev-server 然后在”script”处配置脚本语言 &quot;dev&quot;: &quot;webpack-dev-server --content-base dist --port 6200 --color --progress --hot --inline&quot;想要运行这段脚本，需要这样用npm run dev 就可以构建一个服务器了。 Loaders通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说把ES6转换为现代浏览器可以识别的JS文件。或者使用React开发时，合适的Loaders可以把React的JSX文件转换为JS文件。Loaders需要单独安装并且需要在webpack.config.js下的modules关键字下进行配置，Loaders的配置选项包括以下几方面： test：一个匹配loaders所处理的文件的拓展名的正则表达式（必须） loader：loader的名称（必须） include/exclude:手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹）（可选）； query：为loaders提供额外的设置选项（可选） Babel首先安装babel需要的依赖1$ npm install --save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react 在webpack中的配置如下12345678910111213141516module.exports = &#123; entry: "./src/main.jsx", output: &#123; path: path.join(__dirname, "dist"), filename: "bundle.js", &#125;, module: &#123; loaders: [ &#123; test: /\.jsx$/, loader: "babel", exclude: /node_modules/, &#125; ] &#125;&#125; Babel其实可以完全在webpack.config.js中进行配置，但是考虑到babel具有非常多的配置选项，在单一的webpack.config.js文件中进行配置往往使得这个文件显得太复杂，因此一些开发者支持把babel的配置选项放在一个单独的名为 “.babelrc” 的配置文件中。我们现在的babel的配置并不算复杂，不过之后我们会再加一些东西，因此现在我们就提取出相关部分，分两个配置文件进行配置（webpack会自动调用.babelrc里的babel配置选项），如下： 123&#123; &quot;presets&quot;: [&quot;react&quot;, &quot;es2015&quot;]&#125; CSSwebpack提供两个工具处理样式表css-loader和style-loader，二者处理的任务不同css-loader使你能够使用类似@import和url(...)的方法实现require()的功能,style-loader将所有的计算后的样式加入页面中，二者组合在一起使你能够把样式表嵌入webpack打包后的JS文件中。1$ npm install --save style-loader stylus stylus-loader css-loader 在webpack中的配置如下12345678910111213141516171819202122232425module.exports = &#123; entry: "./src/main.jsx", output: &#123; path: path.join(__dirname, "dist"), filename: "bundle.js", &#125;, module: &#123; loaders: [ &#123; test: /\.jsx$/, loader: "babel", exclude: /node_modules/, &#125;, &#123; test: /\.styl$/, exclude: /node_modules/, loader: "style!css!stylus", &#125;, &#123; test: /\.css$/, loader: "style!css", &#125;, ] &#125;&#125; 在前面提到过，webpack只有单一的入口，其它的模块需要通过import,require,url等导入相关位置，为了让webpack能找到main.css文件，我们把它导入main.jsx中，如下1234//main.jsximport React from &apos;react&apos;;import &#123;render&#125; from &apos;react-dom&apos;;import &apos;./scr/main.css&apos;;//使用require导入css文件 以上就是目前使用到的webpack的一些知识啦~后期还会继续完善的。]]></content>
      <categories>
        <category>front End</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Vim入门的一些小知识以及操作符]]></title>
    <url>%2F2016%2F10%2F12%2FVim%E5%85%A5%E9%97%A8%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Vim是什么？ Vim - the ubiquitous text editorVim is a highly configurable text editor built to make creating and changing any kind of text very efficient. It is included as “vi” with most UNIX systems and with Apple OS X. 如何使用Vim?打开终端，输入vim，便可以运行vim编辑器。打开Vim后直接默认进入普通模式，在普通模式下，每一个按键有独特的含义（按下a并不会输入a这个字符），所以这个时候你按键是不会有反应的，按下小i键(insert)或者小a键(append)就可以进入插入模式，这时每个按键就变成了相应字符的输入。按下ESC就可以返回普通模式。 普通模式下操作符的使用。Vim强大的编辑能力就来源于其普通模式命令。学会了这些操作符并且能灵活组合运用的话就可以更加高效的进行文本编辑。接下来就介绍一下实用的指令吧。如果是使用Sublime作为编程工具的话也可以使用一下指令哦。 简单的移动 h:左 j:下 k:上 l:右使用这些操作符就再也不用在字母键和箭头键之间来回切换啦。b(back/光标向前移动一个单词)0 (光标移动到当前行行首)$ (光标移动到当前行尾)gg（跳转到文档开头）G(跳转到文档末尾)e(跳转到每个单词的末尾字母) 文本对象 w (word/光标向后移动一个单词)t (tag)&#39; (‘’之间的内容)&quot;&quot;(“”之间的内容)(,{,[这些也是同样的原理 对文档的操作 d (delete)dd(删除全行)dw (删除单词)xdd(x代表数字，e.g:2dd删除两行) y (yank/复制)yy (复制整行)xyy (复制x行) e.g:cw(改单词)cit(更改标签里的内容)ci&quot;(更改””里的内容)ci( (更改) p(paste/粘贴) u(undo/撤销) 这些就是简单的Vim操作符啦，也可以说是很常用的，刚用的时候很不习惯，但是用习惯了就会发现这可以大大的提高效率的！]]></content>
      <categories>
        <category>front End</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16.04安装deb软件包步骤]]></title>
    <url>%2F2016%2F09%2F19%2Fubuntu16.04%E5%AE%89%E8%A3%85deb%E8%BD%AF%E4%BB%B6%E5%8C%85%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[前言一直以来在OS X环境下写代码，忽然想起自己还安装了一个Linux发行版ubuntu 14.04，近日升级到ubuntu16.04系统后，却一度卡在了一些图形界面软件的安装上，解决之后寻思还是记录一下以供参考吧，水平有限，求大神勿喷。 像之前一样，从官网上下载到deb软件包，然后双击打开，会自动跳转到ubuntu软件界面，但这次好像有些不一样，无论如何点击“安装”，都无法顺利成功安装。好吧，当时确实有些懵了，后来从命令行的方式上尝试一下安装，才知道是由于缺少一些依赖导致的。 deb软件包deb包是debian，ubuntu等Linux发行版的软件安装包，是类似于rpm的软件包，而非debian,ubuntu系统不推荐使用deb软件包，因为要解决软件包依赖问题，安装也比较麻烦。 步骤第一步当然是去相应的官网下载对应的Linux版本安装包啦，今天我们只讨论deb包的情况。 双击打开deb软件包，会自动跳到ubuntu软件，但这里我们遇到了无法直接双击安装啦。 顺便提一句，Ubuntu 软件中心已在 Ubuntu 16.04 中被取消，取而代之的是 GNOME Software。「软件」是一个外观更现代、浏览更迅捷的商店应用，我们可以使用它来安装和更新应用程序。 打开终端，这里以安装“网易云音乐ubuntu16.04（64位）为例，进入deb包所在的目录 12$ lsnetease-cloud-music.deb 输入指令和密码： 12$ sudo dpkg -i netease-cloud-music.deb[sudo] tc 的密码： 之后就出现了下面的情形： 12345678910111213141516171819202122232425262728正在选中未选择的软件包 netease-cloud-music。(正在读取数据库 ... 系统当前共安装有 178887 个文件和目录。)正准备解包 netease-cloud-music.deb ...正在解包 netease-cloud-music (1.0.0) ...dpkg: 依赖关系问题使得 netease-cloud-music 的配置工作不能继续： netease-cloud-music 依赖于 libqt5x11extras5 (&gt;= 5.1.0)；然而： 未安装软件包 libqt5x11extras5。 netease-cloud-music 依赖于 gstreamer1.0-plugins-bad；然而： 未安装软件包 gstreamer1.0-plugins-bad。 netease-cloud-music 依赖于 gstreamer1.0-plugins-ugly；然而： 未安装软件包 gstreamer1.0-plugins-ugly。 netease-cloud-music 依赖于 libqt5multimedia5-plugins；然而： 未安装软件包 libqt5multimedia5-plugins。 netease-cloud-music 依赖于 libqt5multimediawidgets5；然而： 未安装软件包 libqt5multimediawidgets5。 netease-cloud-music 依赖于 libqt5libqgtk2；然而： 未安装软件包 libqt5libqgtk2。dpkg: 处理软件包 netease-cloud-music (--install)时出错： 依赖关系问题 - 仍未被配置正在处理用于 hicolor-icon-theme (0.15-0ubuntu1) 的触发器 ...正在处理用于 gnome-menus (3.13.3-6ubuntu3) 的触发器 ...正在处理用于 desktop-file-utils (0.22-1ubuntu5) 的触发器 ...正在处理用于 bamfdaemon (0.5.3~bzr0+16.04.20160415-0ubuntu1) 的触发器 ...Rebuilding /usr/share/applications/bamf-2.index...正在处理用于 mime-support (3.59ubuntu1) 的触发器 ...在处理时有错误发生： netease-cloud-music 好吧，真相大白了，是缺少一些依赖关系的缘故，我们需要运行下面的指令来修正上面的错误： 1$ sudo apt-get -f install 接下来就是静候上述指令修复依赖关系和自动安装一些依赖。等提示符正确返回后，再执行下面的指令安装deb软件包： 1$ sudo dpkg -i netease-cloud-music.deb 等指令执行完成后，deb软件就已经被安装好了。如果仍然未安装成功，此时可尝试重启后再执行安装，因为一些修复的依赖可能需要重启后才能生效。 这里其实就是两个指令，前一个是修复依赖关系和自动下载安装所需的依赖，后一个是dpkg套件管理系统指令，下面来简单介绍一下后者： deb是debian linus的安装格式，跟red hat的rpm非常相似，最基本的安装命令是： 1$ sudo dpkg -i package.deb dpkg是Debian Package的简写，是为Debian专门开发的套件管理系统，方便软件的安装、更新及移除。所有源自Debian的Linux发行版都使用dpkg，例如Ubuntu、Knoppix等。 以下是一些 dpkg 的其他用法： 1.查看package.deb软件包中包含的文件结构（其中-c等价于--contents）： 1$ sudo dpkg -c &lt;package.deb&gt; 2.查看package.deb软件包的详细信息，包括软件名称、版本以及大小等（其中-I等价于--info）： 1$ sudo dpkg -I &lt;package.deb&gt; 3.移除一个已安装的包裹（软件名称可通过dpkg -I命令查看，其中-r等价于--remove）： 1$ sudo dpkg -r &lt;package.deb&gt; 4.完全清除一个已安装的包裹。和 remove 不同的是，remove 只是删掉数据和可执行文件，purge 另外还删除所有的配置文件，其中-P等价于--purge： 1$ sudo dpkg -P &lt;package.deb&gt; 5.查看package.deb软件包安装的所有文件（软件名称可通过dpkg -I命令查看，其中-L等价于--listfiles）： 1$ sudo dpkg -L &lt;package.deb&gt; 6.查看package.deb软件包的详细信息（软件名称可通过dpkg -I命令查看，其中-s等价于--status）： 1$ sudo dpkg -s &lt;package.deb&gt; 7.重新配置一个已经安装的包裹： 1$ sudo dpkg-reconfigure &lt;package.deb&gt;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>.deb</tag>
        <tag>apt-get</tag>
        <tag>dpkg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈JavaScript异步机制与事件队列]]></title>
    <url>%2F2016%2F09%2F12%2F%E6%B5%85%E8%B0%88JavaScript%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[setTimeout这样一个函数大家一定不会陌生，但是对于setTimeout这样看起来很简单的东西，却有一个细节相对比较容易忽视。我们来看一下，对setTimeout的描述通常像这样：给定一个回调及n毫秒的延迟，setTimeout就会在n毫秒后运行该回调。但实际上，这个描述是存在严重缺陷的，只能说在多数情况下，该描述只能算接近正确，但在其他某些情况下，则会出现严重的错误。首先，我们来看一个简单的例子，该例子常常会迷惑JavaScript新手： 12345function f1() &#123; console.log('1')&#125;setTimeout(f1,0)console.log("2") 大家认为运行结果的打印顺序会是先1再2，还是先2再1呢？按照定式思维，setTimeout此时定义了0毫秒延迟后执行f1函数，所以应该是立即执行，打印出1，然后再执行下一条语句打印出2。 但实验之后，我们会发现，结果是先2再1。那在这个过程中，setTimeout究竟都干了些什么呢？要想真正理解setTimeout，我们必须先大致了解JavaScript事件模型。 所有的JavaScript代码都由JavaScript脚本运行时引擎（Runtime），也叫JavaScript解释器来负责解释。在JavaScript解释器调用setTimeout的时候，浏览器的timer模块会进行延时处理，当时间到达的时候（如本例中为0毫秒后），就会产生一个事件排入事件队列（事件队列由浏览器负责维护），setTimeout会立刻返回。setTimeout做的事情就是产生一个事件，然后被放到事件队列里面，此时f1函数根本不会被执行。JavaScript解释器会直接执行下一行代码，直到出现空闲没有任何代码了，这时浏览器才会检查事件队列。如果队列中有事件，则浏览器会挑选出排在最前面的事件，并把此事件的处理器移到JavaScript解释器去执行。事件处理器返回后，我们又回到队列处，继续取出下一个事件的处理器到JavaScript解释器去执行。 所以，console.log(&quot;2&quot;)在没有被执行之前，f1函数不可能被执行，即使setTimeout中的延时为0毫秒。 如果JavaScript解释器一直不空闲，那事件队列中的事件就永远不会被触发，就像下面例子这样：12345678910function f1() &#123; console.log('1')&#125;setTimeout(f1,0)console.log("2")while(true) &#123; &#125; 由于出现了一个while无限循环，造成了线程的阻塞，躺在事件队列里面的f1将永远无法执行。所以输出结果中只会看见2。 123456789for (var i = 1; i &lt; 4; i++) &#123; setTimeout(function()&#123; console.log(i) &#125;,0)&#125;444 这样一个例子为什么会出现这样的输出结果而不是1 2 3，现在就不难理解了吧。同样的缘故，在for循环没有结束之前，事件队列中的function函数是不会被执行的。 所以说，setTimeout和setInterval一样，它们的异步机制决定了其计时精准度严格来说是不准确的。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>异步机制</tag>
        <tag>事件队列</tag>
        <tag>setTimeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell知识小记和常用指令]]></title>
    <url>%2F2016%2F09%2F01%2Fshell%E7%9F%A5%E8%AF%86%E5%B0%8F%E8%AE%B0%E5%92%8C%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[前些日子，整理了一些Shell相关的笔记，在此记录下来备用 shell shell是一个程序，中文名叫命令解释器 所有测试基于bash，shell里面，每个指令有一个返回值，0表示成功，非0表示不成功。上一个指令的返回值可以通过$?查看 cd是shell内建的命令，不是独立的程序 操作系统会自带一些常见指令：如ls cal date等 shell的变量shell的变量可以直接使用name=val这种形式来赋值（注意中间没有空格，不能有空格），查看变量的时候，在变量名前面加上$符。 123$ name=Jerry$ echo $nameJerry 注意：解释name变量的是shell，而不是echo指令，shell解释完毕后把结果交给echo，由echo打印出来 PATH 变量 PATH 变量是shell的一个环境变量，通常情况下，环境变量应该大写。可用在创建它们的shell和从该shell派生的任意子shell或进程中。它们通常被称为全局变量，以区别于局部变量。 PATH是由冒号：分割的，可通过echo $PATH查看： 12$ echo $PATH/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin shell在执行一个程序时，会先去PATH指定的目录中找对应的程序，如果找到了则执行，没找到则会提示command not found。所以，如果把PATH变量赋值为空的话，在shell中我们将无法执行任何二进制程序。 文件描述符，流与重定向每一个程序会默认打开三个流： 标准输入（stdin），标准输出（stdout），标准错误输出（stderr）。 shell使用文件描述符来标识一个流，分别为： 标准输入： 0 标准输出： 1 标准错误输出： 2 a&gt;b，文件描述符a重新定向到b指向的地方。一般是重定向到文件或者设备。注意：b不是指代文件描述符1$ ls 1&gt;a.txt 此时我们在终端里将看不见任何内容，因为ls的输出已经被放到a.txt这个文件里面去了.由于重定向标准输入太常见了，shell允许简写，所以上述代码可直接写成:1$ ls &gt; a.txt 再来看重定向到设备，1$ ls &gt; /dev/null 执行后在终端同样看不到任何结果，因为标准输出被重定向到/dev/null这个设备，而/dev/null是一个“黑洞”设备，数据会被丢弃。相关阅读12$ ls -l &gt; a.txt 2&gt;a.txt$ ls -l &gt; a.txt 2&gt;&amp;1 第一行代码，表示把ls -l的标准输出定向到a.txt，再把标准错误输出（用文件描述符2表示）定向到a.txt。也可以用上述第二行的写法，把某一个描述符定向到另一个描述符的指向，2&gt;&amp;1表示把标准错误输出定向到标准输入的指向，实质上等同于第一行代码。 另外，重定向除了是&gt;，还可以是&gt;&gt;，表示追加:123456789101112131415$ echo abc &gt;a.txt$ cat a.txtabc//将abc写入a.txt$ echo 123 &gt;a.txt$ cat a.txt123//123写入a.txt,原先的abc会被覆盖，不再保留$ echo ABC &gt;&gt;a.txt$ cat a.txt123ABC//新写入的ABC和原先a.txt中的123都在，&gt;&gt;表示追加 管道管道操作符为|，可以将一个指令的标准输出连接到另一个指令的标准输入。 1$ ls | grep A # 将当前目录下所有含有A的文件名列出来 首先ls会输出当前目录下的所有文件，然后标准输出会连接到grep的标准输入，最后grep执行将筛选出当前目录所有含有A的文件名。 命令替换命令替换和重定向有些相似，但区别在于命令替换是将一个命令的输出作为另外一个命令的参数。常用命令格式为：1$ command1 `command2` 其中，command2的输出将作为command1的参数。需要注意的是这里的`符号，被它括起来的内容将作为命令执行，执行后的结果作为command1的参数。例如：1$ cd `pwd` 该命令将pwd命令列出的目录作为cd命令的参数，结果仍然是停留在当前目录下12$ echo `echo 123`123 反引号里的echo会先打印字符串123到标准输出，这个输出将作为外面的echo的参数，再执行后输出字符串123 别名别名就是可以给一个指令创建另外一个名字，一般是用来简化指令的，少打几个字符。 12$ alias tc=ls # 输入tc相当于输入ls$ alias # 直接输入alias，可以看到当前shell中所有的别名 shell通配符{a..z}会自动扩展。 12$ echo A&#123;a..z&#125;Aa Ab Ac Ad Ae Af Ag Ah Ai Aj Ak Al Am An Ao Ap Aq Ar As At Au Av Aw Ax Ay Az *号shell会替你自动替换。 12345678910111213141516$ lsa.jpg b.jpg c.txt d.html//假设当前文件夹包含文件如上$ ls *.jpga.jpg b.jpg//shell会先查找符合*.jpg的文件，找到后把参数*.jpg替换成a.jpg和b.jpg再传给ls执行$ rm *.jpg$ lsc.txt d.html//同样shell会先把*.jpg替换成a.jpg和b.jpg，再传给rm执行删除$ ls *.jpgls: *.jpg: No such file or directoryshell没有找到符合*.jpg的文件，直接把参数*.jpg给ls 子shell，环境变量 环境变量是当前shell中能够被子shell继承的变量，普通变量不能被继承。在子shell里修改变量，是不会影响父shell的。在父shell中存在的变量，会在子shell继承。 使用指令export name=val可将普通变量导出为环境变量。 用圆括号括起来的指令会在子shell中执行，不会对父shell造成影响：(ls)12345678$ pwd/Users/tc/Documents$ (cd ..;ls)Applications Documents MoviesPublic Downloads MusicDesktop Library Pictures$ pwd/Users/tc/Documents 上述代码我们可以看到，父shell目录在/Users/tc/Documents，在子shell中执行cd ..;ls后，对父shell所在目录不会造成影响，仍然在/Users/tc/Documents，并不会返回上一级目录 变量赋值还可以使用这种语法：name=$(command)，子shell前面加上$，会得到command命令的输出做为变量name的值。如：name=$(ls)，会把ls在子shell中的执行结果给变量name。123$ name=$(ls)$ echo $nameApplications Desktop Documents Downloads Library Movies Music Pictures Public shell的配置文件一般为~/.bashrc、~/.zshrc配置文件比较正规的叫法是：运行控制文件(run control)打开shell时，会先加载读取~/.zshrc配置文件 在shell中不换行执行多个指令 使用分号; 使用&amp;&amp;或者||号。 常用指令 ls：list，表示显示当前目录下所有的内容。注意：ls根本不从标准输入里面读取内容，其参数是通过命令行直接提供给它的。 cd：change directory, 改变你当前的工作目录 rm：remove，删除文件或者文件夹，使用的时候需要小心，删除的东西不会到回收站中，会直接删掉 mkdir：make directory，建立文件夹 rmdir：remove directory，删除文件夹，只能删除空的文件夹，非空的文件夹需要使用rm并配合-r参数来删除，也就是rm -r [dir name] cp：copy，拷贝文件，比如cp a.txt b.txt，将a.txt文件拷贝一份，名字叫做b.txt touch：新建一个空的文件，比如touch a.txt，在当前目录下新建一个名叫a.txt的空文件 pwd：print working directory，打印当前的工作目录，也就是你当前在什么目录当中 cat：查看文本文件的内容 open：用来将路径在finder中打开 echo：打印字符串到标准输出 mv：移动或重命名文件 ping：通过检查网络中其他主机的应答信息，来确认网络的连通性，语法：ping[参数]主机名（或ip地址） grep：在文件中搜寻匹配的行并进行输出，语法：grep[参数]&lt;要找的字串&gt;&lt;原文件&gt; exit：退出当前shell export：设置与显示环境变量 which：显示指令的绝对路径，可以用来看一个指令的类型， e.g.123456$ which pwdpwd: shell built-in command$ which cdcd: shell built-in command$ which cal/usr/bin/cal 说明：pwd、cd是shell内建的命令，不是程序，而cal是/usr/bin/目录下的一个二进制程序 其他指令 who：显示当前已登录用户的信息 whoami：显示当前用户名 awk：可以拿来做命令行级别的编辑，比如想挑出数据的第8列：123456789101112131415161718192021222324$ ls -ltotal 0drwx------ 6 tc staff 204 8 21 01:05 Applicationsdrwxr-xr-x@ 6 tc staff 204 8 22 20:17 Applications (Parallels)drwxr-xr-x 22 tc staff 748 8 25 15:24 Desktopdrwx------+ 14 tc staff 476 8 24 22:42 Documentsdrwx------+ 20 tc staff 680 8 25 04:18 Downloadsdrwx------@ 56 tc staff 1904 8 16 21:24 Librarydrwx------+ 7 tc staff 238 7 26 17:47 Moviesdrwx------+ 11 tc staff 374 6 25 17:56 Musicdrwx------+ 6 tc staff 204 8 4 02:08 Picturesdrwxr-xr-x+ 6 tc staff 204 4 7 22:39 Public$ ls -l | awk &apos;&#123;print$8&#125;&apos;01:0520:1715:2422:4204:1821:2417:4717:5602:0822:39 注意：awk后面的参数要跟单引号，因为没有引号或者双引号，会被shell先扩展变量做出解释后再被awk拿到，而跟单引号转义后会被awk直接拿到。 wc：word count，用来统计单词数，用-l：line参数可以来统计行数:1234567891011121314$ ls -ltotal 0drwx------ 6 tc staff 204 8 21 01:05 Applicationsdrwxr-xr-x@ 6 tc staff 204 8 22 20:17 Applications (Parallels)drwxr-xr-x 22 tc staff 748 8 25 15:24 Desktopdrwx------+ 14 tc staff 476 8 24 22:42 Documentsdrwx------+ 20 tc staff 680 8 25 04:18 Downloadsdrwx------@ 56 tc staff 1904 8 16 21:24 Librarydrwx------+ 7 tc staff 238 7 26 17:47 Moviesdrwx------+ 11 tc staff 374 6 25 17:56 Musicdrwx------+ 6 tc staff 204 8 4 02:08 Picturesdrwxr-xr-x+ 6 tc staff 204 4 7 22:39 Public$ ls -l | wc -l 11 从total 0开始一共是11行，说明一共有10个文件 subl命令：后跟路径，可将此目录添加到sublime并启动Sublime Text 编辑器自带一个subl程序，但第一次是无法运行的，因为其存在的默认路径不在$PATH中，建议修改如下：1$ cp /Applications/Sublime\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin e.g.]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>流与重定向</tag>
        <tag>管道</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git指令小记]]></title>
    <url>%2F2016%2F08%2F24%2FGit%E6%8C%87%E4%BB%A4%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言git指令有很多，除了常用的git clone、git init、git add、git commit、git push，一些其他的如分支、回退等指令用到的频率不高，所以整理了一份git指令笔记以备遗忘时查阅 笔记git基本指令git init 初始化一个git仓库git add a.txt 把a.txt 添加到stage（暂存）区 （不在暂存区的文件，git指令是不管的） git add . 用来添加当前目录全部文件到暂存区 git commit -m &#39;我的第一行代码&#39; 把暂存区内容添加到提交区，-m 参数后面引号内容为注释（必须要有注释才能提交） git status用来查看git仓库的状态 git push 用来把本地仓库推到远程仓库 git push -f 用来强制推送到远程，把远程的提交全部覆盖掉 git pull 用于拉取远程仓库的新提交到本地仓库 拓展：git暂存区和工作区详解 &nbsp; &nbsp;git status详细参考说明 zsh安装oh my zsh插件后的简化指令tab键用来补全，调出补全项和切换补全项 gss 或者 gst 查看目录状态 glog 查看提交日志（ q 退出日志页面） ga . 添加文件 gco 相当于git checkout gc -m 相当于 git commit -m &#39;注释&#39; git checkoutgit checkout 的主要功能就是迁出一个分支的特定版本，默认是迁出分支的head版本。 git checkout master 迁出master分支的head版本。 git checkout testing 切换到testing分支上，通过向该命令传递一个-b参数，可实现创建并切换分支的功能 git checkout tag_name 在当前分支上，取出 tag_name 的版本 git checkout master file_name 放弃当前对文件file_name的修改 git checkout commit_id file_name 取文件file_name的 在commit_id时的版本，commit_id为 git commit 时的sha值。 git branchgit branch 列出本地分支，以*开头表示 git branch -r 列出远程仓库中的分支 git branch -a 列出远程与本地仓库的全部分支 123456789$ git branch* master$ git branch -rorigin/master$ git branch -a* master remotes/origin/master 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。 git branch testing 创建名为testing的新分支 git merge hotfix 将hotfix分支合并到当前分支当中去 git branch -d testing 删除名为testing的本地分支，-d选项只能删除已经被当前分支所合并过的分支，而要强制删除没有被合并过的分支，可以使用-D git branch -m oldbranch newbranch 重命名分支，-M用来强制重命名，如newbranch已经存在时 git clone从远程主机克隆一个版本库，需要用到指令git clone1$ git clone https://github.com/jquery/jquery.git 上述命令表示，克隆了jQuery的版本库 git remotegit会要求每个远程主机都要指定一个主机名，我们用git remote命令来管理主机名。 当指令后面不带选项的时候，git remote命令会列出所有远程主机。 12$ git remoteorigin git remote -v可以查看远程主机的网址 git clone克隆版本库的时候，所使用的远程主机会自动被git命名为origin，如果想用其他的主机名，需要用git clone命令的-o选项指定。 123$ git clone -o &lt;其他的主机名&gt; &lt;url&gt;$ git remote&lt;其他的主机名&gt; 上面命令表示，克隆的时候，指定远程主机叫做&lt;其他的主机名&gt;。 git pushgit push命令用于将本地分支的更新，推送到远程主机。 1$ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt; 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。1$ git push origin 上面命令表示，将当前分支推送到origin主机的对应分支。 如果当前分支只有一个追踪分支，那么主机名都可以省略。1$ git push git fetch在远程主机的版本库有了更新（commit）时，需要将这些更新取回本地，这用到git fetch命令。 1$ git fetch &lt;远程主机名&gt; 将某个远程主机的更新，全部取回本地 1$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; 取回远程主机的某个特定分支的更新1$ git fetch origin master 取回origin主机的master分支 git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。 1$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 取回远程主机某个分支的更新，再与本地的某个分支合并12$ git pull origin next:master//取回origin主机的next分支，与本地的master分支合并 如果远程分支是与当前分支合并，则冒号后面的部分可以省略。1$ git pull origin next 上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。12$ git fetch origin$ git merge origin/master git也允许手动建立追踪关系12$ git branch --set-upstream dev origin/master //指定dev分支追踪origin/master分支 若当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名1$ git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。 如果当前分支只有一个追踪分支，连远程主机名都可以省略。1$ git pull 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。 忽略某个被追踪文件的修改如果某些文件已经被跟踪了， 再添加到.gitinore时可能会失效， 可用以下命令来忽略： 1$ git update-index --assume-unchanged filename 撤销可使用指令： 1$ git update-index --no-assume-unchanged filename 后记以上为收集整理的部分git指令，欢迎补充完善，如有遗误，还请指正。]]></content>
      <categories>
        <category>Note</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用纯CSS实现带小三角形的会话框]]></title>
    <url>%2F2016%2F08%2F12%2F%E5%A6%82%E4%BD%95%E7%94%A8%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E5%B8%A6%E5%B0%8F%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%BC%9A%E8%AF%9D%E6%A1%86%2F</url>
    <content type="text"><![CDATA[前言生活中能看到很多带小三角形的会话框，如QQ、微信、时间轴等等，就像这样的：在内容外面都有一个带小三角形的矩形框包围着，看上去视觉效果还不错，于是决定动手写一个，用纯CSS就能实现，下面我们来看一下。 基本原理首先我们来看一下纯CSS实现三角形的原理：其实就是对于border和transparent的应用123456789101112131415161718192021&lt;body&gt; &lt;p&gt;向上的三角:&lt;/p&gt; &lt;div class="top"&gt; &lt;!--向上的三角--&gt; &lt;/div&gt; &lt;p&gt;向下的三角:&lt;/p&gt; &lt;div class="bottom"&gt; &lt;!--向下的三角--&gt; &lt;/div&gt; &lt;p&gt;向左的三角:&lt;/p&gt; &lt;div class="left"&gt; &lt;!--向左的三角--&gt; &lt;/div&gt; &lt;p&gt;向右的三角:&lt;/p&gt; &lt;div class="right"&gt; &lt;!--向右的三角--&gt; &lt;/div&gt;&lt;/body&gt; 再用CSS分别实现向上、下、左、右的三角形123456789101112131415161718192021222324252627282930313233343536/*向上的三角*/.top &#123; width: 0; height:0; border-left:50px solid transparent; border-right:50px solid transparent; border-bottom:50px solid red;&#125; /*向下的三角*/.bottom &#123; width:0; height:0; border-left:50px solid transparent; border-right:50px solid transparent; border-top:50px solid #0066cc;&#125; /*向左的三角*/.left &#123; width:0; height:0; border-top:50px solid transparent; border-bottom:50px solid transparent; border-right:50px solid yellow; &#125; /*向右的三角*/.right &#123; width:0; height:0; border-top:50px solid transparent; border-bottom: 50px solid transparent; border-left: 50px solid green;&#125; 我们将上述代码整理在一起后，来看一下效果： 很简单吧，好了，原理我们已经了解，接下来我们来实现带小三角形的会话框。 实现带小三角形的会话框首先，写出html代码：12345678&lt;div class="dialog"&gt; &lt;div class="trangle"&gt;&lt;!--本Div只用来绘制三角形--&gt; &lt;/div&gt; hello，world&lt;br&gt; hello，world&lt;br&gt; hello，world&lt;br&gt; hello，world&lt;br&gt; &lt;/div&gt; .trangle的div只用来实现小三角形，对这个div用css的border和transparent实现三角形。 再通过定位和会话框组合 看下面css代码： 1234567891011121314151617181920212223242526272829303132/*下面开始来画带三角形的会话框*//*先关掉margin和padding，避免带来干扰*/* &#123; margin: 0; padding: 0;&#125;body&#123; background: gray; font-size: 20px; font-family: Comic Sans MS;&#125;.dialog &#123; margin: 0 auto; margin-top: 15px; width: 300px; background: #fff; padding: 10px; border-radius: 5px;&#125;.trangle&#123; position: absolute; margin-left: -20px; width: 0; height: 0; border-top: 10px solid transparent; border-bottom: 10px solid transparent; border-right: 10px solid #fff;&#125; 效果是这样的： 好了，到这里我们就完工了，剩下的就是做一些美化的工作了。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎样使用Hexo通过Github Pages搭建个人博客]]></title>
    <url>%2F2016%2F07%2F22%2Fhow%20to%20bulid%20your%20blog%20on%20github%20pages%2F</url>
    <content type="text"><![CDATA[前言在搭建博客的过程中参考了一些其他作者的资料，也遇到了一些小问题，所幸在Google之后找到了解决方案，感谢这些作者们，于是我决定把搭建的全过程记录下来，希望能够给大家提供一些参考。 准备工作注册Github账号访问：http://www.github.com/ 配置SSH keys和添加SSH Key到Github1.终端中输入下列指令，生成密钥，一路回车 $ ssh-keygen 出现下面所示则表示密钥成功生成1234567891011121314151617Your identification has been saved in /Users/taochen/.ssh/id_rsa.Your public key has been saved in /Users/taochen/.ssh/id_rsa.pub.The key fingerprint is:SHA256:ckScuB/7NjJDT0OUbtm1dp4lUiPr5mcV3xJqVzcR9Ng taochen@TC-MacBookpro.localThe key&apos;s randomart image is:+---[RSA 2048]----+| o.. . .o.|| ..o o . ++.|| ..o o =.oE|| ... = + =o=|| ..S= . + *O|| o+ o = o.=|| . + = . o || + = . o || = . o |+----[SHA256]-----+TC-MacBookpro:~ taochen$ 2.密钥生成以后，存放在~/.ssh目录中 $ ls ~/.ssh 12$ ls ~/.sshid_rsa id_rsa.pub $ cat ~/.ssh/id_rsa.pub 12$ cat ~/.ssh/id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDA9vWA+ToVHjvMV+9LerF7hdHawqh3ls8OVSsYNfP2ppLS4/w47cWKOR+9Dv6cgqJLstDt7mgnbcpFcztLYZKBy1ZPBgOA1tYtxDIA2pDMIKsYd9M7UosgavCMgBg0dlO1y+xUhnyShqduDHblCCUjM9D+rB6HipeNQWZLWNZ39anPvjTp9ZizdDTtPYi7zaB/fcUatqxeHkFUjHm6WYaC/gQrYsqj1LAonQCdfdgHL8VZg2sXTxl+AOZfX1ZGTs3qXFAoUkDWaMQKC3UNTNrUC9MwNcs/+cLecaDMf+5BBxI71xRP+JLvAy1mTeux2vk0d9FyLU7et9d taochen@TC-MacBookpro.local 复制出密钥内容 3.到github中添加密钥（把ssh的公钥给github） 登陆github系统。点击右上角的 Account Settings—&gt;SSH and GPG keys —&gt;New SSH key —&gt;填写Title和Key 4.最后，点击Add SSH key确认添加密钥 使用Github Pages建立博客github上建立仓库1.在github首页，点击页面中的Start a project 2.输入仓库名：username.github.io (username指你的github用户名，这里以ChenTao92为例) 注：Github Pages的Repository的名字是有规定格式的，否则Github无法识别这个Repository是你的Github账户的Pages 在本地创建名为blog的文件夹，并初始化为git仓库(文件夹名可随意，此处以blog为例)123$ mkdir blog$ cd blog$ git init 这里用于存放建立blog的原始文件 Hexo模板引擎Hexo是什么Hexo是一个简单、快速、强大的博客发布工具，支持Markdown格式，具体详见官方介绍。 安装Hexo1$ npm install -g hexo 初始化Hexo1$ hexo init Hexo引擎随后会自动在目标文件夹里生成建立blog所需的所有文件。 更换Hexo主题复制主题可以去Hexo官网寻找你喜欢的主题，这里我们以选用Apollo主题为例:1.先进入blog下面的themes文件夹12➜ blog git:(master) ✗ cd themes➜ themes git:(master) ✗ 2.将主题的仓库代码克隆到本地1$ git clone https://github.com/pinggod/hexo-theme-apollo.git apllo 启用主题1.在编辑器中打开blog文件夹2.修改_config.yml配置文件中的theme配置项为apollo3._config.yml配置文件中的title和author等信息可根据自己的需要进行更改 验证主题首先启动 Hexo 本地站点1$ hexo s 在服务启动的过程中，注意观察命令行输出是否有任何异常信息，当命令行输出中提示：1INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 此时即可使用浏览器访问 http://localhost:4000 ， 以验证主题是否正确启用。 若遇到主题无法启用，可能还需要安装某些theme插件 若未遇到主题无法启用的问题，本步骤请忽略 具体请参考主题的详细介绍页面，如Apollo主题就需要安装执行下面的指令： 1$ npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive 配置deploy在_config.yml文件中配置deploy（username以ChenTao92为例,请自行替换为自己的username） 123type: gitrepository: git@github.com:ChenTao92/ChenTao92.github.io.gitbranch: master 写博客输入hexo new postName指令即可，postName为你的新博文名称，hexo会在 blog/source/_posts/目录下建立新的.md文件，写入Markdown格式博文即可。 写完博客之后，可以同样先输入命令hexo s启动本地服务，进行文章预览调试。 推送到Github在本地预览无误后，可以执行推送到github的命令：12$ hexo g$ hexo d 遇到“Deployer not found: github”时的解决办法 若未遇到此问题，本步骤请忽略 1$ npm install hexo-deployer-git --save 访问博客在以上步骤都成功完整后，浏览器访问链接 https://{username}.github.io 即可。e.g. : https://chentao92.github.io]]></content>
      <categories>
        <category>Course</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
</search>